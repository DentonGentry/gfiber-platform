#!/bin/selfclean /bin/sh
main_pid=$$

log()
{
  echo "$@" >&2
}


fs_writable()
{
  local dir="$1"
  if ( : >"$dir/.check.tmp" ) 2>/dev/null; then
    rm -f "$dir/.check.tmp"
    return 0
  else
    return 1
  fi
}


is_fat()
{
  [ -e /dev/sda ] && grep -q GFMS /tmp/platform
}


label()
{
  "$@" 2>&1 |
  while read line; do
    echo "$*: $line"
  done
}


retry()
{
  while :; do
    "$@"
    sleep 5
    log "restarting '$*'"
  done
}


should_never_die()
{
  "$@"
  log "FATAL: process ($*) died unexpectedly with code $?"
  kill -TERM $main_pid
  exit 98
}


main()
{
  # Network setup: we hardcode the IP address of fat vs. thin brunos
  # so they can find each other without hassle.  The downside is this means
  # you can only run one fat and one thin bruno per LAN segment for now.
  #
  # We originally tried to stress *both* ethernet and MoCA here, but that's
  # too hard if the bridge device is configured (which is the normal case).
  # So let's just send packets out the bridge interface, if it exists, or
  # eth0, otherwise.  The net effect is we'll end up sending packets over
  # MoCA if the thin bruno is connected over MoCA, or ethernet if it's
  # connected over ethernet, which is a lot like what should happen in real
  # life.

  if ip link show br0; then
    ethdev=br0
  else
    ethdev=eth0
  fi
  if is_fat; then
    log 'Fat bruno: address 169.254.1.1'
    ip addr add 169.254.1.1/24 dev $ethdev
  else
    log 'Thin bruno: address 169.254.1.2'
    ip addr add 169.254.1.2/24 dev $ethdev
  fi

  should_never_die label iperf -s &
  should_never_die label iperf -s -u &

  IPERF_TCP="retry label iperf -t3600 -i10   "
  IPERF_UDP="retry label iperf -t3600 -i10 -u"
  if is_fat; then
    $IPERF_TCP -c 169.254.1.2 &
    $IPERF_UDP -c 169.254.1.2 &
  else
    $IPERF_TCP -c 169.254.1.1 &
    $IPERF_UDP -c 169.254.1.1 &
  fi

  if fs_writable /var/media; then
    # fast random writes
    should_never_die stress-disk -p10 --random --write /var/media &
  else
    log "No /var/media; skipping disk-write test."
  fi

  # raw disk/usb reads
  for d in /dev/sd?; do
    if [ -e "$d" ]; then
      # fast sequential read (to force some seeks)
      should_never_die stress-disk -p10 "$d" &

      # slow small random read
      should_never_die stress-disk -p0 -c4096 -m10 --random "$d" &
    fi
  done

  # NAND reads
  #TODO(apenwarr): don't hardcode the device name; read it from /proc/mtd
  #TODO(apenwarr): -c65536 causes memory allocation problems.
  # This seems to be because the MTD driver tries to allocate kernel memory
  # the same size as the read() parameter as a single contiguous block,
  # which, under heavy load, might not be available.  There's no good reason
  # for MTD to do this, afaik, so we could try to debug the kernel so we
  # can increase this parameter.  It could theoretically cause problems on
  # a normal system under high load, not just one being stresstested.
  should_never_die stress-disk -p10 -c4096 /dev/mtd12 &

  # NOR reads
  #TODO(apenwarr): don't hardcode the device name; read it from /proc/mtd
  #TODO(apenwarr): see above about -c65536.
  should_never_die stress-disk -p10 -c4096 /dev/mtd1 &

  sleep 5
  #TODO(apenwarr): actually bind the following to cpu0 and cpu1
  should_never_die nice -n 19 spin cpu0-idle &
  should_never_die nice -n 19 spin cpu1-idle &

  wait
}


main 2>&1 | tee /proc/self/fd/2 | logger -t stresstest
